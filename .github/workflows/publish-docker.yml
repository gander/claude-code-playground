name: Docker Build and Publish

on:
  # Automatic trigger after successful NPM publish
  workflow_run:
    workflows: ["Publish to NPM (Manual Dispatch)"]
    types:
      - completed
    branches:
      - master

  # Manual trigger with version input
  workflow_dispatch:
    inputs:
      version:
        description: 'NPM package version to build (e.g., v1.2.3)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  extract-version:
    name: Extract Version and Validate
    runs-on: ubuntu-latest
    outputs:
      version-tag: ${{ steps.version.outputs.version-tag }}
      should-build: ${{ steps.version.outputs.should-build }}
      is-release: ${{ steps.version.outputs.is-release }}

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0

      - name: Extract version from trigger
        id: version
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION_TAG=""
          SHOULD_BUILD="false"
          IS_RELEASE="false"

          # workflow_run - triggered after NPM publish
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Check if workflow_run was successful
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "::warning::NPM publish workflow failed, skipping Docker build"
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Get the latest draft release (created by publish-npm.yml)
            VERSION_TAG=$(gh release list --limit 1 --json tagName,isDraft --jq '.[] | select(.isDraft == true) | .tagName')

            if [ -z "$VERSION_TAG" ]; then
              echo "::error::Failed to find draft release from npm publish workflow"
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            IS_RELEASE="true"
            SHOULD_BUILD="true"
            echo "âœ… Building Docker image for version: $VERSION_TAG (from npm publish workflow)"

          # workflow_dispatch - manual trigger with version
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_TAG="${{ inputs.version }}"

            # Validate version format
            if ! [[ "$VERSION_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::Invalid version format: '$VERSION_TAG'. Expected semantic version (e.g., v1.2.3)"
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            # Check if release exists
            if ! gh release view "$VERSION_TAG" --repo "${{ github.repository }}" > /dev/null 2>&1; then
              echo "::error::Release $VERSION_TAG does not exist. Create release first via publish-npm.yml workflow."
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            IS_RELEASE="true"
            SHOULD_BUILD="true"
            echo "âœ… Manual Docker build for version: $VERSION_TAG"

          # push tag - version tag trigger
          elif [[ "${{ github.ref }}" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            VERSION_TAG="${{ github.ref_name }}"
            IS_RELEASE="true"
            SHOULD_BUILD="true"
            echo "âœ… Version tag build: $VERSION_TAG"

          # push master - edge build
          elif [ "${{ github.ref }}" = "refs/heads/master" ]; then
            VERSION_TAG="edge"
            IS_RELEASE="false"
            SHOULD_BUILD="true"
            echo "âœ… Edge build from master branch"

          # pull_request - PR build
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            VERSION_TAG="pr-${{ github.event.pull_request.number }}"
            IS_RELEASE="false"
            SHOULD_BUILD="true"
            echo "âœ… PR build: $VERSION_TAG"

          else
            echo "::warning::Unknown trigger, skipping build"
            SHOULD_BUILD="false"
          fi

          {
            echo "version-tag=$VERSION_TAG"
            echo "is-release=$IS_RELEASE"
            echo "should-build=$SHOULD_BUILD"
          } >> "$GITHUB_OUTPUT"

  validate-branch:
    name: Validate Tag is on Master Branch
    runs-on: ubuntu-latest
    needs: extract-version
    # Only run for release builds triggered by tags (not workflow_run or workflow_dispatch)
    if: needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/')
    outputs:
      is-master: ${{ steps.check.outputs.is-master }}
      should-deploy: ${{ steps.check.outputs.should-deploy }}

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0  # Fetch full history to check branch ancestry

      - name: Check if tag was created from master branch
        id: check
        run: |
          # Get the commit SHA that the tag points to
          TAG_COMMIT=$(git rev-list -n 1 "${{ github.ref_name }}")
          echo "Tag ${{ github.ref_name }} points to commit: ${TAG_COMMIT}"

          # Check if this commit is reachable from master
          if git merge-base --is-ancestor "${TAG_COMMIT}" origin/master; then
            echo "âœ… Tag ${{ github.ref_name }} was created from master branch"
            echo "is-master=true" >> "$GITHUB_OUTPUT"
            echo "should-deploy=true" >> "$GITHUB_OUTPUT"
          else
            echo "âŒ Tag ${{ github.ref_name }} was NOT created from master branch"
            echo ""
            echo "ðŸš« Docker deployment blocked for security reasons:"
            echo "   Tags must be created from the master branch to trigger releases"
            echo "   This prevents accidental releases from feature branches"
            echo ""
            echo "ðŸ”§ To fix this:"
            echo "   1. Delete this tag: git tag -d ${{ github.ref_name }} && git push origin :refs/tags/${{ github.ref_name }}"
            echo "   2. Checkout master: git checkout master"
            echo "   3. Create tag from master: git tag ${{ github.ref_name }} && git push origin ${{ github.ref_name }}"
            echo ""
            echo "is-master=false" >> "$GITHUB_OUTPUT"
            echo "should-deploy=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: [extract-version, validate-branch]
    # Run if:
    # 1. Should build (from extract-version)
    # 2. Not a tag trigger (validate-branch will be skipped) OR validation passed
    if: |
      always() &&
      needs.extract-version.outputs.should-build == 'true' && (
        !startsWith(github.ref, 'refs/tags/') ||
        (needs.validate-branch.result == 'success' && needs.validate-branch.outputs.should-deploy == 'true')
      )

    permissions:
      contents: read
      packages: write
      id-token: write  # For Cosign keyless signing
      attestations: write  # For build attestations
      security-events: write  # For uploading Trivy SARIF results

    steps:
      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@28fdb31ff34708d19615a74d67103ddc2ea9725c
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=1000
            type=raw,value=${{ needs.extract-version.outputs.version-tag }},enable=${{ needs.extract-version.outputs.is-release == 'true' }},priority=900
            type=edge,enable=${{ needs.extract-version.outputs.version-tag == 'edge' }},priority=800
            type=ref,event=pr,priority=700
            type=semver,pattern={{major}},enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=600
            type=semver,pattern={{major}}.{{minor}},enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=500
            type=semver,pattern={{major}}.{{minor}}.{{patch}},enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=400

      - name: Download dist/ artifact from GitHub Release (release builds only)
        if: needs.extract-version.outputs.is-release == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION_TAG="${{ needs.extract-version.outputs.version-tag }}"
          echo "ðŸ“¦ Downloading dist.tar.gz from release $VERSION_TAG"

          gh release download "$VERSION_TAG" \
            --repo ${{ github.repository }} \
            --pattern 'dist.tar.gz'

          echo "ðŸ“‚ Extracting dist.tar.gz"
          tar xzf dist.tar.gz

          echo "âœ“ dist/ artifact ready ($(du -sh dist | cut -f1))"
          ls -lh dist/

      - name: Set up Node.js (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '22'

      - name: Install npm 11.5.1 (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        run: npm install -g npm@11.5.1

      - name: Install dependencies (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        run: npm ci

      - name: Build (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        run: npm run build

      - name: Build and push Docker image (release builds with artifact)
        if: needs.extract-version.outputs.is-release == 'true'
        id: build-and-push-release
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83
        with:
          context: .
          file: Dockerfile.release
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Build and push Docker image (development builds from source)
        if: needs.extract-version.outputs.is-release == 'false'
        id: build-and-push-dev
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Set digest output
        id: digest
        run: |
          if [ "${{ needs.extract-version.outputs.is-release }}" = "true" ]; then
            echo "digest=${{ steps.build-and-push-release.outputs.digest }}" >> "$GITHUB_OUTPUT"
          else
            echo "digest=${{ steps.build-and-push-dev.outputs.digest }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Image digest
        run: echo "Image pushed with digest ${{ steps.digest.outputs.digest }}"

      # Vulnerability Scanning with Trivy
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@0499de31b99561a6d14a36a5f662c2a54f91beee
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      # Image Signing with Cosign
      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad

      - name: Sign container image with Cosign
        env:
          DIGEST: ${{ steps.digest.outputs.digest }}
        run: |
          echo "Signing image with digest: ${DIGEST}"
          cosign sign --yes --recursive \
            "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST}"

      # Send webhook notification when 'latest' tag is published
      - name: Send webhook for latest tag publication
        if: needs.extract-version.outputs.is-release == 'true'
        env:
          WEBHOOK_URL: ${{ secrets.DOCKER_PUBLISH_LATEST_WEBHOOK }}
          IMAGE_DIGEST: ${{ steps.digest.outputs.digest }}
          CLIENT_ID: ${{ secrets.CF_ACCESS_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CF_ACCESS_CLIENT_SECRET }}
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            echo "::warning::DOCKER_PUBLISH_LATEST_WEBHOOK secret not set, skipping webhook"
            exit 0
          fi

          if [ -z "$CLIENT_ID" ]; then
            echo "::warning::CF_ACCESS_CLIENT_ID secret not set, skipping webhook"
            exit 0
          fi

          if [ -z "$CLIENT_SECRET" ]; then
            echo "::warning::CF_ACCESS_CLIENT_SECRET secret not set, skipping webhook"
            exit 0
          fi

          echo "Sending webhook notification for latest tag publication..."

          # Send POST request to webhook
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions" \
            -H "CF-Access-Client-Id: $CLIENT_ID" \
            -H "CF-Access-Client-Secret: $CLIENT_SECRET" \
            "$WEBHOOK_URL")

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "::notice::âœ“ Webhook sent successfully (HTTP $HTTP_CODE)"
          else
            echo "::error::âœ— Webhook failed with HTTP $HTTP_CODE"
          fi
