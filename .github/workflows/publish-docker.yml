name: Docker Build and Publish

on:
  # Automatic trigger after successful Release Please workflow
  workflow_run:
    workflows: ["Release Please"]
    types:
      - completed
    branches:
      - master

  # Manual trigger with version input
  workflow_dispatch:
    inputs:
      version:
        description: 'NPM package version to build (e.g., v1.2.3)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  extract-version:
    name: Extract Version and Validate
    runs-on: ubuntu-latest
    outputs:
      version-tag: ${{ steps.version.outputs.version-tag }}
      should-build: ${{ steps.version.outputs.should-build }}
      is-release: ${{ steps.version.outputs.is-release }}

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: Extract version from trigger
        id: version
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION_TAG=""
          SHOULD_BUILD="false"
          IS_RELEASE="false"

          # workflow_run - triggered after Release Please workflow
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Check if workflow_run was successful
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "::warning::Release Please workflow failed, skipping Docker build"
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Get the latest release (created by release-please.yml)
            VERSION_TAG=$(gh release list --limit 1 --json tagName,isDraft --jq '.[] | select(.isDraft == false) | .tagName')

            if [ -z "$VERSION_TAG" ]; then
              echo "::error::Failed to find release from Release Please workflow"
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            IS_RELEASE="true"
            SHOULD_BUILD="true"
            echo "âœ… Building Docker image for version: $VERSION_TAG (from Release Please workflow)"

          # workflow_dispatch - manual trigger with version
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_TAG="${{ inputs.version }}"

            # Validate version format
            if ! [[ "$VERSION_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::Invalid version format: '$VERSION_TAG'. Expected semantic version (e.g., v1.2.3)"
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            # Check if release exists
            if ! gh release view "$VERSION_TAG" --repo "${{ github.repository }}" > /dev/null 2>&1; then
              echo "::error::Release $VERSION_TAG does not exist. Create release first via publish-npm.yml workflow."
              echo "should-build=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            IS_RELEASE="true"
            SHOULD_BUILD="true"
            echo "âœ… Manual Docker build for version: $VERSION_TAG"

          # push master - edge build
          elif [ "${{ github.ref }}" = "refs/heads/master" ]; then
            VERSION_TAG="edge"
            IS_RELEASE="false"
            SHOULD_BUILD="true"
            echo "âœ… Edge build from master branch"

          # pull_request - PR build
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            VERSION_TAG="pr-${{ github.event.pull_request.number }}"
            IS_RELEASE="false"
            SHOULD_BUILD="true"
            echo "âœ… PR build: $VERSION_TAG"

          else
            echo "::warning::Unknown trigger, skipping build"
            SHOULD_BUILD="false"
          fi

          {
            echo "version-tag=$VERSION_TAG"
            echo "is-release=$IS_RELEASE"
            echo "should-build=$SHOULD_BUILD"
          } >> "$GITHUB_OUTPUT"

  build-and-push:
    runs-on: ubuntu-latest
    needs: extract-version
    if: needs.extract-version.outputs.should-build == 'true'

    permissions:
      contents: read
      packages: write
      id-token: write  # For Cosign keyless signing
      attestations: write  # For build attestations
      security-events: write  # For uploading Trivy SARIF results

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@65d18f8f8a05aab1b2d761032bec9cd5578caadb

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@28fdb31ff34708d19615a74d67103ddc2ea9725c
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable=${{ needs.extract-version.outputs.is-release == 'true' }},priority=1000
            type=raw,value=${{ needs.extract-version.outputs.version-tag }},enable=${{ needs.extract-version.outputs.is-release == 'true' }},priority=900
            type=edge,enable=${{ needs.extract-version.outputs.version-tag == 'edge' }},priority=800
            type=ref,event=pr,priority=700
            type=semver,pattern={{major}},enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=600
            type=semver,pattern={{major}}.{{minor}},enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=500
            type=semver,pattern={{major}}.{{minor}}.{{patch}},enable=${{ needs.extract-version.outputs.is-release == 'true' && startsWith(github.ref, 'refs/tags/v') }},priority=400

      - name: Download dist/ artifact from GitHub Release (release builds only)
        if: needs.extract-version.outputs.is-release == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION_TAG="${{ needs.extract-version.outputs.version-tag }}"
          echo "ðŸ“¦ Downloading dist.tar.gz from release $VERSION_TAG"

          gh release download "$VERSION_TAG" \
            --repo ${{ github.repository }} \
            --pattern 'dist.tar.gz'

          echo "ðŸ“‚ Extracting dist.tar.gz"
          tar xzf dist.tar.gz

          echo "âœ“ dist/ artifact ready ($(du -sh dist | cut -f1))"
          ls -lh dist/

      - name: Set up Node.js (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '24'

      - name: Install npm 11.6.4 (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        run: npm install -g npm@11.6.4

      - name: Install dependencies (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        run: npm ci

      - name: Build (non-release builds)
        if: needs.extract-version.outputs.is-release == 'false'
        run: npm run build

      - name: Build and push Docker image (release builds with artifact)
        if: needs.extract-version.outputs.is-release == 'true'
        id: build-and-push-release
        uses: docker/build-push-action@9e436ba9f2d7bcd1d038c8e55d039d37896ddc5d
        with:
          context: .
          file: Dockerfile.release
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Build and push Docker image (development builds from source)
        if: needs.extract-version.outputs.is-release == 'false'
        id: build-and-push-dev
        uses: docker/build-push-action@9e436ba9f2d7bcd1d038c8e55d039d37896ddc5d
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Set digest output
        id: digest
        run: |
          if [ "${{ needs.extract-version.outputs.is-release }}" = "true" ]; then
            echo "digest=${{ steps.build-and-push-release.outputs.digest }}" >> "$GITHUB_OUTPUT"
          else
            echo "digest=${{ steps.build-and-push-dev.outputs.digest }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Image digest
        run: echo "Image pushed with digest ${{ steps.digest.outputs.digest }}"

      # Vulnerability Scanning with Trivy
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@267c4672a565967e4531438f2498370de5e8a98d
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      # Image Signing with Cosign
      - name: Install Cosign
        uses: sigstore/cosign-installer@29bcfa8619aeb12eaac78d31157172c86183b05c

      - name: Sign container image with Cosign
        env:
          DIGEST: ${{ steps.digest.outputs.digest }}
        run: |
          echo "Signing image with digest: ${DIGEST}"
          cosign sign --yes --recursive \
            "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST}"

      # Send webhook notification when 'latest' tag is published
      - name: Send webhook for latest tag publication
        if: needs.extract-version.outputs.is-release == 'true'
        env:
          WEBHOOK_URL: ${{ secrets.DOCKER_PUBLISH_LATEST_WEBHOOK }}
          IMAGE_DIGEST: ${{ steps.digest.outputs.digest }}
          CLIENT_ID: ${{ secrets.CF_ACCESS_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CF_ACCESS_CLIENT_SECRET }}
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            echo "::warning::DOCKER_PUBLISH_LATEST_WEBHOOK secret not set, skipping webhook"
            exit 0
          fi

          if [ -z "$CLIENT_ID" ]; then
            echo "::warning::CF_ACCESS_CLIENT_ID secret not set, skipping webhook"
            exit 0
          fi

          if [ -z "$CLIENT_SECRET" ]; then
            echo "::warning::CF_ACCESS_CLIENT_SECRET secret not set, skipping webhook"
            exit 0
          fi

          echo "Sending webhook notification for latest tag publication..."

          # Send POST request to webhook
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions" \
            -H "CF-Access-Client-Id: $CLIENT_ID" \
            -H "CF-Access-Client-Secret: $CLIENT_SECRET" \
            "$WEBHOOK_URL")

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "::notice::âœ“ Webhook sent successfully (HTTP $HTTP_CODE)"
          else
            echo "::error::âœ— Webhook failed with HTTP $HTTP_CODE"
          fi
