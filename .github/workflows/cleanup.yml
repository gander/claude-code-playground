name: Hourly Cleanup

on:
  schedule:
    - cron: '0 * * * *'  # Co godzinę o pełnej godzinie
  workflow_dispatch:      # Manualny trigger dla testowania

# Top-level permissions: read-only by default (principle of least privilege)
permissions:
  contents: read

env:
  GH_TOKEN: ${{ secrets.PAT_PACKAGES }}

jobs:
  cleanup-packages:
    name: Clean Old Package Versions
    runs-on: ubuntu-latest
    # Minimal permissions required for package cleanup
    permissions:
      packages: write  # Required to delete package versions via GitHub Packages API
      contents: read   # Required for checkout

    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4.2.2

      - name: Random delay to avoid rate limits
        run: sleep $((RANDOM % 30))

      - name: Check rate limit before start
        run: |
          rate_info=$(gh api rate_limit --jq '.resources.core')
          echo "Rate limit info: $rate_info"
          remaining=$(echo "$rate_info" | jq -r '.remaining')
          echo "Remaining requests: $remaining"

          # Przerwij jeśli zostało mniej niż 100 requestów
          if [ "$remaining" -lt 100 ]; then
            echo "::warning::Rate limit too low ($remaining remaining), skipping cleanup"
            exit 0
          fi

      - name: Cleanup package versions
        run: |
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          PACKAGE_TYPE="container"
          MIN_KEEP=3  # Zachowaj tylko 3 najnowsze wersje (uruchamiamy co godzinę)

          echo "Fetching packages for ${OWNER}/${REPO}..."

          # Owner is organization
          OWNER_TYPE="orgs"

          # Get packages
          packages=$(gh api --paginate "/${OWNER_TYPE}/${OWNER}/packages?package_type=${PACKAGE_TYPE}" 2>&1)

          # Check if API call failed
          if echo "$packages" | grep -q '"message"'; then
            echo "Error fetching packages:"
            echo "$packages" | jq -r '.message // .'
            exit 0
          fi

          # Filter packages for this repository
          packages=$(echo "$packages" | jq -r ".[] | select(.repository.name == \"${REPO}\") | .name" 2>/dev/null || true)

          if [ -z "$packages" ]; then
            echo "No packages found for repository ${REPO}"
            exit 0
          fi

          for package in $packages; do
            echo "Processing package: $package"

            # URL-encode package name (e.g., "org/repo" -> "org%2Frepo")
            package_encoded=$(echo -n "$package" | jq -sRr @uri)

            # Get versions sorted by creation date (oldest first)
            versions=$(gh api --paginate \
              "/${OWNER_TYPE}/${OWNER}/packages/${PACKAGE_TYPE}/${package_encoded}/versions?per_page=100" 2>&1)

            # Check if API call failed
            if echo "$versions" | grep -q '"message"'; then
              echo "Error fetching versions for ${package}:"
              echo "$versions" | jq -r '.message // .'
              continue
            fi

            # Parse versions
            versions=$(echo "$versions" | jq -c 'sort_by(.created_at) | .[] | {id: .id, created: .created_at, tags: .metadata.container.tags}' 2>/dev/null || true)

            if [ -z "$versions" ]; then
              echo "No versions found for $package"
              continue
            fi

            # Count total versions
            total=$(echo "$versions" | jq -s 'length')
            echo "Total versions: $total"

            if [ "$total" -le "$MIN_KEEP" ]; then
              echo "Only $total versions, keeping all (MIN_KEEP=$MIN_KEEP)"
              continue
            fi

            to_delete=$((total - MIN_KEEP))
            echo "Will delete $to_delete oldest versions"

            count=0
            echo "$versions" | jq -c '.' | while read -r version; do
              count=$((count + 1))
              if [ $count -gt $to_delete ]; then
                break
              fi

              version_id=$(echo "$version" | jq -r '.id')
              created=$(echo "$version" | jq -r '.created')
              tags=$(echo "$version" | jq -r '.tags[]?' 2>/dev/null || echo "untagged")

              echo "Deleting version ID: $version_id (created: $created, tags: $tags)"
              gh api -X DELETE \
                "/${OWNER_TYPE}/${OWNER}/packages/${PACKAGE_TYPE}/${package_encoded}/versions/${version_id}" \
                2>&1 | tee /tmp/delete_result.txt

              if grep -q '"message"' /tmp/delete_result.txt 2>/dev/null; then
                echo "✗ Failed to delete:"
                cat /tmp/delete_result.txt | jq -r '.message // .'
              else
                echo "✓ Deleted"
              fi

              sleep 1  # Rate limit protection
            done

            echo "Finished processing $package"
            echo "---"
          done

  cleanup-workflow-runs:
    name: Clean Old Workflow Runs
    runs-on: ubuntu-latest
    # Minimal permissions required for workflow runs cleanup
    permissions:
      actions: write   # Required to delete workflow runs via GitHub Actions API
      contents: read   # Required for checkout

    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4.2.2

      - name: Random delay
        run: sleep $((RANDOM % 30))

      - name: Check rate limit
        run: |
          rate_info=$(gh api rate_limit --jq '.resources.core')
          echo "Rate limit info: $rate_info"
          remaining=$(echo "$rate_info" | jq -r '.remaining')
          echo "Remaining requests: $remaining"

          if [ "$remaining" -lt 100 ]; then
            echo "::warning::Rate limit too low ($remaining remaining), skipping cleanup"
            exit 0
          fi

      - name: Cleanup workflow runs
        run: |
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          MIN_KEEP=10  # Zachowaj tylko 10 najnowszych runs (uruchamiamy co godzinę)

          echo "Fetching workflows for ${OWNER}/${REPO}..."

          # Get workflows
          workflows=$(gh api "/repos/${OWNER}/${REPO}/actions/workflows" 2>&1)

          # Check if API call failed
          if echo "$workflows" | grep -q '"message"'; then
            echo "Error fetching workflows:"
            echo "$workflows" | jq -r '.message // .'
            exit 0
          fi

          # Parse workflows
          workflows=$(echo "$workflows" | jq -c '.workflows[] | {id: .id, name: .name}' 2>/dev/null || true)

          if [ -z "$workflows" ]; then
            echo "No workflows found"
            exit 0
          fi

          echo "$workflows" | jq -c '.' | while read -r workflow; do
            workflow_id=$(echo "$workflow" | jq -r '.id')
            workflow_name=$(echo "$workflow" | jq -r '.name')

            echo "Processing workflow: $workflow_name (ID: $workflow_id)"

            # Check total count of completed runs
            first_page=$(gh api "/repos/${OWNER}/${REPO}/actions/workflows/${workflow_id}/runs?per_page=1&status=completed" 2>&1)

            if echo "$first_page" | grep -q '"message"'; then
              echo "Error fetching runs count for ${workflow_name}:"
              echo "$first_page" | jq -r '.message // .'
              continue
            fi

            total_count=$(echo "$first_page" | jq -r '.total_count // 0')
            echo "Total completed runs: $total_count"

            if [ "$total_count" -le "$MIN_KEEP" ]; then
              echo "Only $total_count runs, keeping all (MIN_KEEP=$MIN_KEEP)"
              continue
            fi

            to_delete=$((total_count - MIN_KEEP))
            echo "Will delete $to_delete oldest runs (keeping newest $MIN_KEEP)"

            # Use pagination to skip first MIN_KEEP runs (newest)
            # GitHub API returns newest first, so we skip page 1 (first MIN_KEEP runs)
            # and delete everything from page 2 onwards
            page=2
            deleted_total=0

            while true; do
              echo "Fetching page $page..."
              runs=$(gh api "/repos/${OWNER}/${REPO}/actions/workflows/${workflow_id}/runs?per_page=${MIN_KEEP}&page=${page}&status=completed" 2>&1)

              # Check if API call failed
              if echo "$runs" | grep -q '"message"'; then
                echo "Error fetching runs page ${page}:"
                echo "$runs" | jq -r '.message // .'
                break
              fi

              # Count runs on this page
              run_count=$(echo "$runs" | jq '.workflow_runs | length')
              if [ "$run_count" -eq 0 ]; then
                echo "No more runs to delete"
                break
              fi

              echo "Processing $run_count runs from page $page..."

              # Extract run IDs to array (avoids subshell variable issues)
              run_ids=$(echo "$runs" | jq -r '.workflow_runs[].id')

              # Delete each run
              for run_id in $run_ids; do
                # Get run details for logging
                run_details=$(echo "$runs" | jq -r ".workflow_runs[] | select(.id == $run_id) | {created: .created_at, conclusion: .conclusion}")
                created=$(echo "$run_details" | jq -r '.created')
                conclusion=$(echo "$run_details" | jq -r '.conclusion')

                echo "Deleting run ID: $run_id (created: $created, conclusion: $conclusion)"
                delete_result=$(gh api -X DELETE "/repos/${OWNER}/${REPO}/actions/runs/${run_id}" 2>&1)

                if echo "$delete_result" | grep -q '"message"'; then
                  echo "✗ Failed to delete:"
                  echo "$delete_result" | jq -r '.message // .'
                else
                  echo "✓ Deleted"
                  deleted_total=$((deleted_total + 1))
                fi

                sleep 1  # Rate limit protection
              done

              page=$((page + 1))
            done

            echo "Finished processing $workflow_name (deleted $deleted_total runs)"
            echo "---"
          done

      - name: Final rate limit check
        run: |
          rate_info=$(gh api rate_limit --jq '.resources.core')
          echo "Final rate limit: $rate_info"
          remaining=$(echo "$rate_info" | jq -r '.remaining')
          echo "Remaining requests: $remaining"
